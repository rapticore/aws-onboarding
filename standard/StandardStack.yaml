AWSTemplateFormatVersion: 2010-09-09
Parameters:
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VpcId of your existing Virtual Private Cloud (VPC)
    ConstraintDescription: must be the VPC Id of an existing Virtual Private Cloud.

  SubnetId:
    Type: AWS::EC2::Subnet::Id
    Description: SubnetId of an existing public subnet (for the primary network) in selected Virtual Private Cloud (VPC)
    ConstraintDescription: must be an existing public subnet in the selected Virtual Private Cloud.

  EC2InstanceType:
    Description: Rapticore Server EC2 instance type
    Type: String
    Default: t3.large
    ConstraintDescription: must be a valid EC2 instance type.
    AllowedValues: [t3.medium, t3.large, t3.2xlarge, c3.large, c3.xlarge, c3.2xlarge, c3.4xlarge, c4.large, c4.xlarge, c4.2xlarge, c4.4xlarge, c5.large, c5.xlarge, c5.2xlarge, c5.4xlarge, c5a.large, c5a.xlarge, c5a.2xlarge, c5a.4xlarge]

  Domain:
    Description: 'The domain name of your Rapticore instance.'
    Type: String
    ConstraintDescription: must be a valid domain name i.e., domain.ore.rapticore.cloud

  HostedZoneID:
    Description: 'The ID of your Route 53 hosted zone. Domain name record will be created in this zone.'
    Type: 'AWS::Route53::HostedZone::Id'

  AzureIdentityLambdaArn:
    Description: 'ARN of existing Lambda function to use for Custom Resource to create identity for azure tenant in identity pool'
    Type: String

  TenantId:
    Type: String
    Description: Unique tenant identifier

  CognitoGroupName:
    Type: String
    Description: Cognito group name for this tenant

  CrsAccountId:
    Type: String
    Description: AWS Account ID where CRS runs
    Default: "422753814403"

  CognitoManagementRoleArn:
    Type: String
    Description: ARN of role in CRS account for Cognito management
    Default: "arn:aws:iam::422753814403:role/cognito-management-for-standard-tenants"

  SharedUserPoolId:
    Type: String
    Description: Shared Cognito User Pool ID
    Default: "us-west-2_ugQoEHBWd"

  SharedUserPoolClientId:
    Type: String
    Description: Shared Cognito User Pool Client ID
    Default: "3c0adcuesr3fjrc1tri6g78uf"

Resources:
  #####
  # Network resources
  #####
  RapticoreSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Enable HTTP access
      VpcId: !Ref VpcId
      Tags:
        - Key: Name
          Value: Rapticore-Standard-Security-Group
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 6100
          ToPort: 6100
          CidrIp: 0.0.0.0/0

  NetworkLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Join [ "", [ !Select [0, !Split [., !Ref Domain ]],'-elb' ] ]
      IpAddressType: ipv4
      Scheme: internet-facing
      Subnets: [!Ref SubnetId]
      Type: network
      Tags:
          - Key: 'Name'
            Value: !Join [ "", [!Ref Domain,'-loadbalancer' ] ]

  NetworkLoadBalancerTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Join [ "", [ !Select [0, !Split [., !Ref Domain ]],'-target-group' ] ]
      Port: 443
      Protocol: TLS
      VpcId: !Ref VpcId
      TargetType: instance
      Targets:
        - Id: !Ref EC2Instance

  # Set up TLS Cert
  Cert:
    Type: 'AWS::CertificateManager::Certificate'
    Properties:
      DomainName: !Ref Domain
      ValidationMethod: DNS

  NetworkLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref NetworkLoadBalancerTargetGroup
      LoadBalancerArn: !Ref NetworkLoadBalancer
      Port: 443
      Protocol: TLS
      Certificates:
        - CertificateArn: !Ref Cert

  #####
  # EC2 resources
  #####
  EC2InstanceProfileRoleForRapticore:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - "ec2.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      Description: !Sub 'Rapticore Standard EC2 IAM Role Deployment'
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - iam:ListRole*
                  - ec2:DescribeRegions
                  - iam:GetRole*
                Effect: Allow
                Resource: '*'
                Sid: AllowIamEc2ReadyOnly
              - Action: sts:AssumeRole
                Effect: Allow
                Resource: 'arn:aws:iam::*:role/rapticore*'
                Sid: EC2AssumeRole
          PolicyName: RapticoreEc2Policy
        - PolicyDocument:
            Statement:
              - Action:
                  - sqs:ChangeMessageVisibility
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:GetQueueUrl
                  - sqs:ListDeadLetterSourceQueues
                  - sqs:ListQueueTags
                  - sqs:ListQueues
                  - sqs:ReceiveMessage
                  - sqs:SendMessage
                Effect: Allow
                Resource: arn:aws:sqs:us-west-2:343027753149:real-time-threat-alert-trigger
                Sid: AllowRapticoreRealtimeAlert
          PolicyName: RapticoreRealTimeAlertPolicy
        - PolicyDocument:
            Statement:
              - Action: 'cognito-identity:GetOpenIdTokenForDeveloperIdentity'
                Effect: Allow
                Resource: !Sub 'arn:aws:cognito-identity:${AWS::Region}:${AWS::AccountId}:identitypool/${AzureWorkloadIdentityPool}'
                Sid: AllowCognitoOpenIdToken
          PolicyName: CognitoOpenIdTokenPolicy
      RoleName: !Join [ "", [ 'RapticoreStandardEc2IAMRole', !Select [0, !Split [., !Ref Domain ]] ] ]

  EC2InstanceProfileForRapticore:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2InstanceProfileRoleForRapticore

  EC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      IamInstanceProfile: !Ref EC2InstanceProfileForRapticore
      ImageId: ami-09ca9451840476dc8
      InstanceType: !Ref EC2InstanceType
      SecurityGroupIds:
        - !Ref RapticoreSecurityGroup
      SubnetId: !Ref SubnetId
      Tags:
        - Key: Name
          Value: !Join [ "", [!Ref Domain,'Rapticore-standard' ] ]

  # Set up A Record via Route 53
  Route53Record:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !Ref HostedZoneID
      Comment: Route 53 record for Rapticore Standard
      RecordSets:
        - Name: !Ref Domain
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt 'NetworkLoadBalancer.CanonicalHostedZoneID'
            DNSName: !GetAtt NetworkLoadBalancer.DNSName

  #####
  # Azure Workload Identity Resources
  #####
  AzureWorkloadIdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties:
      IdentityPoolName: !Join
        - ''
        - - 'azure_workload_identity_pool_'
          - !Select [ 0, !Split [ '.', !Ref Domain ] ]
      AllowUnauthenticatedIdentities: false
      DeveloperProviderName: !Join
        - ''
        - - 'azure_workload_identity_'
          - !Select [ 0, !Split [ '.', !Ref Domain ] ]

  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref AzureIdentityLambdaArn
      Principal: 'cloudformation.amazonaws.com'
      SourceAccount: !Ref 'AWS::AccountId'

  # Custom Resource that uses the existing Lambda function
  GetOpenIdTokenCustomResource:
    Type: Custom::GetOpenIdToken
    DependsOn:
      - LambdaPermission
    Properties:
      ServiceToken: !Ref AzureIdentityLambdaArn
      IdentityPoolId: !Ref AzureWorkloadIdentityPool
      #####
      # Login Key should be same as developer provider name
      #####
      LoginKey: !Join
        - ''
        - - 'azure_workload_identity_'
          - !Select [ 0, !Split [ '.', !Ref Domain ] ]
      LoginValue: !Select [ 0, !Split [ '.', !Ref Domain ] ]

  #####
  # CRS Cross-Account Authentication Resources
  #####
  CrsServiceUserPassword:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "CrsServiceUserPassword-${TenantId}"
      GenerateSecretString:
        SecretStringTemplate: !Sub '{"username": "crs-service-${TenantId}@rapticore.com"}'
        GenerateStringKey: password
        ExcludeCharacters: '"@/\'
        PasswordLength: 32
        RequireEachIncludedType: true

  CrsUserManagementRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CognitoUserManagement
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sts:AssumeRole
                Resource: !Ref CognitoManagementRoleArn
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref CrsServiceUserPassword

  CrsUserManagementFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "CrsUserManagement-${TenantId}"
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt CrsUserManagementRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse
          
          def handler(event, context):
              try:
                  # Assume cross-account role first
                  sts = boto3.client('sts')
                  cognito_mgmt_role_arn = event['ResourceProperties']['CognitoManagementRoleArn']
                  
                  assumed_role = sts.assume_role(
                      RoleArn=cognito_mgmt_role_arn,
                      RoleSessionName='cognito-user-management'
                  )
                  
                  # Create Cognito client with assumed role credentials
                  cognito = boto3.client(
                      'cognito-idp',
                      region_name='us-west-2',
                      aws_access_key_id=assumed_role['Credentials']['AccessKeyId'],
                      aws_secret_access_key=assumed_role['Credentials']['SecretAccessKey'],
                      aws_session_token=assumed_role['Credentials']['SessionToken']
                  )
                  
                  secrets = boto3.client('secretsmanager')
                  
                  user_pool_id = event['ResourceProperties']['UserPoolId']
                  username = event['ResourceProperties']['Username']
                  group_name = event['ResourceProperties']['GroupName']
                  password_secret_arn = event['ResourceProperties']['PasswordSecretArn']
                  
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      # Check if group exists, create if not
                      try:
                          cognito.get_group(GroupName=group_name, UserPoolId=user_pool_id)
                          print(f"Group {group_name} already exists")
                      except cognito.exceptions.ResourceNotFoundException:
                          print(f"Creating group {group_name}")
                          cognito.create_group(
                              GroupName=group_name,
                              UserPoolId=user_pool_id,
                              Description=f"CRS tenant group for {group_name}"
                          )
                      
                      # Check if user exists
                      user_exists = False
                      try:
                          cognito.admin_get_user(UserPoolId=user_pool_id, Username=username)
                          user_exists = True
                          print(f"User {username} already exists")
                      except cognito.exceptions.UserNotFoundException:
                          print(f"User {username} does not exist, creating")
                      
                      if not user_exists:
                          # Get password from secret
                          secret = secrets.get_secret_value(SecretId=password_secret_arn)
                          password_data = json.loads(secret['SecretString'])
                          password = password_data['password']
                          
                          # Create user
                          cognito.admin_create_user(
                              UserPoolId=user_pool_id,
                              Username=username,
                              MessageAction='SUPPRESS',
                              TemporaryPassword='TempPassword123!'
                          )
                          
                          # Set permanent password
                          cognito.admin_set_user_password(
                              UserPoolId=user_pool_id,
                              Username=username,
                              Password=password,
                              Permanent=True
                          )
                      
                      # Always ensure user is in group
                      try:
                          cognito.admin_add_user_to_group(
                              UserPoolId=user_pool_id,
                              Username=username,
                              GroupName=group_name
                          )
                      except cognito.exceptions.UserNotConfirmedException:
                          pass  # User already in group
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Username': username})
                  
                  elif event['RequestType'] == 'Delete':
                      # Don't delete user - preserve it for reuse
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})

  CreateCrsServiceUser:
    Type: Custom::CrsServiceUser
    Properties:
      ServiceToken: !GetAtt CrsUserManagementFunction.Arn
      UserPoolId: !Ref SharedUserPoolId
      Username: !Sub "crs-service-${TenantId}@rapticore.com"
      GroupName: !Ref CognitoGroupName
      PasswordSecretArn: !Ref CrsServiceUserPassword
      CognitoManagementRoleArn: !Ref CognitoManagementRoleArn
      Timestamp: "2025-08-17-19-11"

  CrsCredentials:
    Type: AWS::SecretsManager::Secret
    DependsOn: CreateCrsServiceUser
    Properties:
      Name: !Sub "CrsCredentials-${TenantId}"
      SecretString: !Sub |
        {
          "tenant_id": "${TenantId}",
          "aws_region": "us-west-2",
          "user_pool_id": "${SharedUserPoolId}",
          "client_id": "${SharedUserPoolClientId}",
          "service_username": "crs-service-${TenantId}@rapticore.com",
          "service_password": "{{resolve:secretsmanager:${CrsServiceUserPassword}:SecretString:password}}",
          "target_account_id": "${AWS::AccountId}",
          "api_endpoint": "https://${Domain}/api/v1/ingest/sarif",
          "cognito_group": "${CognitoGroupName}",
          "cross_account_role_arn": "arn:aws:iam::${CrsAccountId}:role/crs-cognito-access-standard-tenancy"
        }

Outputs:
  RapticoreStandardURL:
    Value: !Join [ "", [ "https://", !Ref Domain ] ]
    Description: Rapticore Standard URL

  RapticoreStandardInstanceId:
    Description: Instance ID of the launched EC2 instance
    Value: !Ref EC2Instance
    Export:
      Name: !Join [ "", [ "RapticoreStandardInstanceId-", !Select [0, !Split [., !Ref Domain ]] ] ]

  AzureWorkloadIdentityPoolId:
    Description: The ID of the Cognito Identity Pool for Azure workload identity
    Value: !Ref AzureWorkloadIdentityPool

  CreatedIdentityId:
    Description: The ID of the created identity in the identity pool
    Value:
      Fn::GetAtt:
        - GetOpenIdTokenCustomResource
        - IdentityId

  CrsServiceUsername:
    Description: CRS Service Username created
    Value: !Sub "crs-service-${TenantId}@rapticore.com"

  CrsRoleArn:
    Description: Cross-account role ARN for CRS authentication (in CRS account)
    Value: !Ref CognitoManagementRoleArn

  CrsCredentialsSecret:
    Description: Secret containing CRS authentication details
    Value: !Ref CrsCredentials